//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

//import jdk.nashorn.internal.codegen.SpillObjectCreator;



/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJDepthFirst<R,A> implements GJVisitor<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //

   //keeping track of iteration
   int iteration = -1;

   HashMap<Integer, Set<String>> use;
   HashMap<Integer, Set<String>> def;
   HashMap<Integer, Set<String>> in;
   HashMap<Integer, Set<String>> out;
   HashMap<Integer, Set<Integer>> adj;
   HashMap<String, Integer> label_line = new HashMap<String, Integer>();

   //live intervals
   public class LiveRange {
      String temp;
      int start_line;
      int end_line;
   }

   public class AscendingStart implements Comparator<LiveRange> {
      public int compare(LiveRange l1, LiveRange l2) {
         if(l1.start_line > l2.start_line) return 1;
         else if(l1.start_line < l2.start_line) return -1;
         return 0;
      }     
   }

   public class AscendingEnd implements Comparator<LiveRange> {
      public int compare(LiveRange l1, LiveRange l2) {
         if(l1.end_line > l2.end_line) return 1;
         else if(l1.end_line < l2.end_line) return -1;
         return 0;
      }     
   }


   HashMap<String, Integer> temp_index;

   Vector<LiveRange> live_ranges;

   int line_number = 0;
   String type; // "use" or "def"
   String to_store_in;

   //labels 
   int curr_label = 0;
   HashMap<String, String> label_allocated = new HashMap<String, String>();
   boolean to_print_label = false;

   //register allocated 
   String curr_function;   
   String no_of_args;
   HashMap<String, HashMap<String, String>> allocations = new HashMap<String, HashMap<String, String>>();
   HashMap<String, HashMap<String, Integer>> allocations_start = new HashMap<String, HashMap<String, Integer>>();
   HashMap<String, Integer> function_spills = new HashMap<String, Integer>();
   HashMap<String, Integer> functions_max_call = new HashMap<String, Integer> ();

   //for allocations
   PriorityQueue<LiveRange> active;
   PriorityQueue<LiveRange> live_intervals;

   //registers
   int available_registers = 18;
   HashMap<String, Boolean> free_registers;
   HashMap<LiveRange, String> register;

   int stack_locations = 0;
   int spills = 0;
   int max_arg_call;
   boolean call_exp = false;
   int arg_num = 0;

   public void findInOut() {
      in = new LinkedHashMap<Integer, Set<String>>();
      out = new LinkedHashMap<Integer, Set<String>>();
      //for all block B- in[B] = null, out[B] = null
      for(Integer block: adj.keySet()) {
         Set<String> block_var = new HashSet<String> ();
         in.put(block, block_var);
         out.put(block, block_var);
      }

      boolean changed = true;

      while(changed) {
         boolean status = false;
         for(Integer block: adj.keySet()) {
            Set<String> in1_b = in.get(block);
            Set<String> out1_b = out.get(block);
            Set<String> in_b = new HashSet<String>();
            Set<String> out_b = new HashSet<String>();
            out_b.addAll(out1_b);
            Set<String> out_m_def = out_b;
            //out[b] - def[b]
            if(def.get(block) != null) out_m_def.removeAll(def.get(block));
            //in[b] = use[b] U (out[b] - def[b])
            if(use.get(block) != null) in_b.addAll(use.get(block));
            in_b.addAll(out_m_def);
            

            Set<Integer> nei = adj.get(block);
            //for all succ s, out[b] = U in[s]
            for(Integer i: nei) {
               if(in.get(i) != null) {
                  out_b.addAll(in.get(i));
               }
            }

            in.replace(block, in_b);
            out.replace(block, out_b);

            if(in1_b.equals(in_b) && out1_b.equals(out_b)) {
               status = status | false;
            } else status = status | true;
         }
         changed = status;
      }

      // System.out.println(curr_function);

      // for(Integer block: in.keySet()) {
      //    System.out.println("Block In " + block + ": " + in.get(block));
      // }
      // for(Integer block: out.keySet()) {
      //    System.out.println("Block Out " + block + ": " + out.get(block));
      // }
   }

   public void findLiveInterval() {
      for(Integer block: adj.keySet()) {
         Set<String> live_till = in.get(block);
         Set<String> live_from = out.get(block);
         for(String temp: live_till) {
            LiveRange t;
            if(temp_index.containsKey(temp)) {
               int index = temp_index.get(temp);
               t = live_ranges.get(index);
               t.end_line = block;
            }
         }
         for(String temp: live_from) {
            if(temp_index.containsKey(temp)) continue;
            LiveRange t;
            t = new LiveRange();
            t.temp = temp;
            t.start_line =  block;
            t.end_line = block;
            temp_index.put(temp, live_ranges.size());
            live_ranges.add(t);
         }
      }
      // System.out.println(curr_function);
      // for(LiveRange t: live_ranges) {
      //    System.out.println(t.temp+": live-from: " + t.start_line + "; live-till: "+t.end_line);
      // }
   }

   public void initialize() {
      //for live ranges
      live_intervals = new PriorityQueue<LiveRange>(live_ranges.size(), new AscendingStart());

      for(LiveRange t: live_ranges) {
         live_intervals.add(t);
      }

      register = new HashMap<LiveRange, String> ();
      free_registers = new LinkedHashMap<String, Boolean> ();

      //s0-7
      for(int i = 0; i<8; i++) {
         String reg = "s"+i;
         free_registers.put(reg, true);
      }
      
      //t0-9
      for(int i = 0; i<10; i++) {
         String reg = "t"+i;
         free_registers.put(reg, true);
      }
   }

   public void addFreedReg(String reg) {
      free_registers.replace(reg, true);
   }

   public String getFreeReg() {
      for(String reg: free_registers.keySet()) {
         if(free_registers.get(reg)) {
            free_registers.replace(reg, false);
            return reg;
         }
      }

      return null;
   }

   public void expireOldIntervals(LiveRange i) {
      while(!active.isEmpty()) {
         LiveRange j = active.peek();
         if(j.end_line > i.start_line) return;
         active.poll();
         addFreedReg(register.get(j));
      }
   }

   public LiveRange getLastInterval() {
      Vector<LiveRange> temp = new Vector<LiveRange>();
      while(!active.isEmpty()) {
         temp.add(active.poll());
      }
      LiveRange last = temp.lastElement();
      for(LiveRange t: temp) {
         active.add(t);
      }
      temp.clear();
      return last;
   }

   public void spillAtInterval(LiveRange i) {
      LiveRange spill = getLastInterval();   
      int args = Integer.parseInt(no_of_args);
      if(args > 4) args -= 4;
      else args = 0;
      String location = "l"+(spills+args);
      spills++;

      if(spill.end_line > i.end_line) {
         register.put(i, register.get(spill));
         register.replace(spill, location);
         active.remove(spill);
         active.add(i);
      } else {
         register.put(i, location);
      }
   }

   public void allocateRegisters() {
      initialize();
      
      active = new PriorityQueue<LiveRange> (live_ranges.size(), new AscendingEnd());

      while(!live_intervals.isEmpty()) {
         LiveRange i = live_intervals.poll();
         expireOldIntervals(i);
         if(active.size() == available_registers) 
            spillAtInterval(i);
         else {
            String toAllocate = getFreeReg();
            register.put(i, toAllocate);
            active.add(i);
         }
      }

   }

	
   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return (R)n.tokenImage; }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */

   
   public R visit(Procedure n, A argu) {
      R _ret=null;
      stack_locations = 0;
      //creating flow graph
      adj = new LinkedHashMap<Integer, Set<Integer>>();
      Set<Integer> nei = new HashSet<Integer>();
      line_number++;      
      nei.add(line_number+1);
      adj.put(line_number, nei);

      //initializing variables for stack size, max call etc.
      call_exp = false;
      max_arg_call = -1;
      int stack_size = 8;
      spills = 0;  

      //initializing use and def for the function
      use = new HashMap<Integer, Set<String>>();
      def = new HashMap<Integer, Set<String>>();

      String label = (String) n.f0.accept(this, argu);
      curr_function = label;

      if(iteration == 1) {
         max_arg_call = functions_max_call.get(curr_function);
         if(max_arg_call == -1) {
            max_arg_call = 0;
         } else stack_size+=(10);
      }

      n.f1.accept(this, argu);

      String int_literal = (String) n.f2.accept(this, argu);    

      n.f3.accept(this, argu);

      if(iteration == 1) {
         int arguments = Integer.parseInt(int_literal);
         if(arguments > 4) {
            stack_size+=(arguments-4); 
            stack_locations=(arguments-4);
         }
         int spill = function_spills.get(curr_function);
         if(spill != 0) {
            stack_size += spill;
            stack_locations += spill;
         }
         System.out.println(label + " [" + int_literal + "] [" + stack_size + "] [" + max_arg_call + "]");
      }

      //initializing for the live ranges
      temp_index = new HashMap<String, Integer>();
      live_ranges = new Vector<LiveRange> ();
      no_of_args = int_literal;

      if(iteration == 0) {
         for(int i = 0; i<Integer.parseInt(int_literal); i++) {
            Set<String> def_var;
            String temp = Integer.toString(i);
            if(def.containsKey(line_number)) {
               def_var = def.get(line_number);
               def_var.add(temp);
               def.replace(line_number, def_var);
            } else {
               def_var = new HashSet<String>();
               def_var.add(temp);
               def.put(line_number, def_var);
            }
         }
      }
      
      n.f4.accept(this, argu);

      if(iteration == 0) {
         // System.out.println(curr_function);
         // for(int line: use.keySet()) {
         //    System.out.print("line use: "+line + " : ");
         //    for(String var: use.get(line)) {
         //       System.out.print(var+" ");
         //    }
         //    System.out.println();
         // }
         // for(int line: def.keySet()) {
         //    System.out.print("line def: "+line + " : ");
         //    for(String var: def.get(line)) {
         //       System.out.print(var+" ");
         //    }
         //    System.out.println();
         // }
         findInOut();
         findLiveInterval();
      }

      if(iteration == 0) allocateRegisters();

      if(iteration == 0) {
         HashMap<String, String> temp = new HashMap<String, String> ();
         HashMap<String, Integer> temp_start = new HashMap<String, Integer>();
         // System.out.println(curr_function);

         for(LiveRange t: register.keySet()) {
            // System.out.println(t.temp + ": " + register.get(t));
            temp.put(t.temp, register.get(t));
            temp_start.put(t.temp, t.start_line);
         }

         allocations.put(curr_function, temp);
         allocations_start.put(curr_function, temp_start);
         function_spills.put(curr_function, spills);
         functions_max_call.put(curr_function, max_arg_call);
      }

      return _ret;
   }

//
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      R _ret=null;
      line_number = 0; //starts the program with line number 0

      //creating flow graph
      adj = new LinkedHashMap<Integer, Set<Integer>>();
      Set<Integer> nei = new HashSet<Integer>();
      line_number++;
      nei.add(line_number+1);
      adj.put(line_number, nei);

      n.f0.accept(this, argu);

      //initializing variables of required values
      curr_function = "MAIN";
      call_exp = false;
      max_arg_call = -1;
      int stack_size = 0;
      spills = 0;
      no_of_args = "0";

      //initializing use and def for the main block
      use = new HashMap<Integer, Set<String>>();
      def = new HashMap<Integer, Set<String>>();

      if(iteration == 1) {
         max_arg_call = functions_max_call.get(curr_function);
         if(max_arg_call == -1) {
            max_arg_call = 0;
         } else stack_size+=(10);

         int spill = function_spills.get(curr_function);
         if(spill != 0) {
            stack_size += spill;
            stack_locations = spill;
         }

         System.out.println("MAIN [" + no_of_args + "] [" + stack_size + "] [" + max_arg_call + "]");
      }

      //initializing for the live ranges
      temp_index = new HashMap<String, Integer>();
      live_ranges = new Vector<LiveRange> ();

      n.f1.accept(this, argu);

      if(iteration == 0) {
         // for(int line: use.keySet()) {
         //    System.out.print("line: "+line + " : ");
         //    for(String var: use.get(line)) {
         //       System.out.print(var+" ");
         //    }
         //    System.out.println();
         // }
         // for(int line: def.keySet()) {
         //    System.out.print("line: "+line + " : ");
         //    for(String var: def.get(line)) {
         //       System.out.print(var+" ");
         //    }
         //    System.out.println();
         // }
         findInOut();
         findLiveInterval();
      }

      if(iteration == 0) {
         allocateRegisters();
      }

      //for the flow graph
      nei = new HashSet<Integer>();
      line_number++;
      nei.add(line_number+1);
      adj.put(line_number, nei);

      n.f2.accept(this, argu);

      if(iteration == 1) {
         System.out.println("END");
         if(function_spills.get(curr_function) != 0) System.out.println("// SPILLED");
         else System.out.println("// NOTSPILLED");
      }
      
      if(iteration == 0) {
         HashMap<String, String> temp = new HashMap<String, String> ();
         HashMap<String, Integer> temp_start = new HashMap<String, Integer> ();

         for(LiveRange t: register.keySet()) {
            // System.out.println(t.temp + ": " + register.get(t));
            temp.put(t.temp, register.get(t));
            temp_start.put(t.temp, t.start_line);
         }

         allocations.put(curr_function, temp);
         allocations_start.put(curr_function, temp_start);
         function_spills.put(curr_function, spills);
         functions_max_call.put(curr_function, max_arg_call);
      }

      n.f3.accept(this, argu);
      n.f4.accept(this, argu);       
      
      iteration++;

      return _ret;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
      R _ret=null;
      to_print_label = true;
      n.f0.accept(this, argu);
      to_print_label = false;
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) {
      R _ret=null; 
      Set<Integer> nei = new HashSet<Integer>();
      line_number++;
      //creating flow graph
      nei.add(line_number+1);
      adj.put(line_number, nei);

      n.f0.accept(this, argu);

      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      if(iteration == 1) {
         System.out.println("NOOP");
      }
      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
      R _ret=null;

      n.f0.accept(this, argu);

      if(iteration == 1) {
         System.out.println("ERROR");
      }
      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) {
      R _ret=null;

      Set<Integer> nei = adj.get(line_number);

      int cjump_l = line_number;

      String cjump = (String) n.f0.accept(this, argu);

      type = "use";
      String use_temp = (String) n.f1.accept(this, argu);
      type = "null";

      boolean init = to_print_label;
      to_print_label = false;
      String label = (String) n.f2.accept(this, argu);
      to_print_label = init;

      //for the flow graph
      if(iteration == 0) {
         // System.out.println(curr_function+"_"+label +": " + label_line.get(curr_function+"_"+label));
         nei.add(label_line.get(curr_function+"_"+label));
         adj.replace(cjump_l, nei);
      }

      if(iteration == 1) System.out.println(cjump + " " + use_temp +" " + label);

      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) {
      R _ret=null;
      Set<Integer> nei = adj.get(line_number);

      int jump_l = line_number;

      String jump = (String) n.f0.accept(this, argu);

      boolean init = to_print_label;
      to_print_label = false;
      String label = (String) n.f1.accept(this, argu);
      to_print_label = init;

      //for the flow graph
      if(iteration == 0) {
         nei.add(label_line.get(curr_function+"_"+label));
         adj.replace(jump_l, nei);
      }

      if(iteration == 1) System.out.println(jump + " " + label);

      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) {
      R _ret=null;

      String hstore = (String) n.f0.accept(this, argu);

      type = "use";
      String def_temp = (String) n.f1.accept(this, argu);
      type = "null";   
      
      //taking care of multi spill
      if(iteration == 1) {
         if(def_temp.equals("v1")) {
            System.out.println("MOVE v0 v1");
            def_temp = "v0";
         }
      }

      String int_literal = (String) n.f2.accept(this, argu);

      type = "use";
      String use_temp = (String) n.f3.accept(this, argu);
      type = "null";

      if(iteration == 1) {
         System.out.println(hstore + " " + def_temp + " " + int_literal + " " + use_temp);
      }
      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) {
      R _ret=null;

      String hload = (String) n.f0.accept(this, argu);

      type = "def";
      String def_temp = (String) n.f1.accept(this, argu);
      type = "null";

      type = "use";
      String use_temp = (String) n.f2.accept(this, argu);
      type = "null";

      String int_literal = (String) n.f3.accept(this, argu);

      if(iteration == 1) {
         System.out.println(hload + " " + def_temp + " " + use_temp + " " + int_literal);
         if(def_temp.equals("v0")) System.out.println("ASTORE SPILLEDARG " + to_store_in + " v0");
      }
      
      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) {
      R _ret=null;

      String move = (String) n.f0.accept(this, argu);

      type = "def";
      String temp = (String) n.f1.accept(this, argu); 
      type = "null";

      type = "use";
      String exp = (String) n.f2.accept(this, argu);
      type = "null";

      if(call_exp && iteration == 1) {
         System.out.println(move + " " + temp + " v0");
         if(temp.equals("v0")) System.out.println("ASTORE SPILLEDARG " + to_store_in + " v0");
         call_exp = false;
      } else if(iteration == 1) {
         System.out.println(move + " " + temp + " " + exp);
         if(temp.equals("v0")) System.out.println("ASTORE SPILLEDARG " + to_store_in + " v0");
      }

      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) {
      R _ret=null;
      String prit = (String) n.f0.accept(this, argu);
      type = "use";
      String sim_exp = (String) n.f1.accept(this, argu);    
      type = "null";

      if(iteration == 1) {
         System.out.println(prit + " " + sim_exp);
      }

      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) {
      R _ret=null;
      type = "use";
      _ret = n.f0.accept(this, argu);
      type = "null";
      return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n, A argu) {
      R _ret=null;

      //creating flow graph
      Set<Integer> nei = new HashSet<Integer>();
      line_number++;
      nei.add(line_number+1);
      adj.put(line_number, nei);

      n.f0.accept(this, argu);

      if(iteration == 1) {
         for(int i = 0; i<8; i++) {
            System.out.println("ASTORE SPILLEDARG " + stack_locations + " s"+i);
            stack_locations++;
         }
         int till = Integer.min(Integer.parseInt(no_of_args), 4);
         for(int i = 0; i<till; i++) {
            String al_reg = allocations.get(curr_function).get(Integer.toString(i));
            if(al_reg != null) {
               if(al_reg.charAt(0) == 'l') {
                  System.out.println("MOVE v0 a" + i);
                  System.out.println("ASTORE SPILLEDARG " + al_reg.substring(1) + " v0");
               }
               else System.out.println("MOVE " + al_reg + " a" + i);
            }
         }
      }

      n.f1.accept(this, argu);

      //creating flow graph
      nei = new HashSet<Integer>();
      line_number++;
      nei.add(line_number+1);
      adj.put(line_number, nei);

      n.f2.accept(this, argu);

      type = "use";
      String sim_exp = (String) n.f3.accept(this, argu);
      type = "null";

      //creating  flow graph
      nei = new HashSet<Integer>();
      line_number++;
      nei.add(line_number+1);
      adj.put(line_number, nei);

      n.f4.accept(this, argu);

      if(iteration == 1) {
         System.out.println("MOVE v0 " + sim_exp);
         for(int i = 0; i<8; i++) {
            System.out.println("ALOAD s"+i + " SPILLEDARG " + (stack_locations - 8+i));
         }
         stack_locations-=8;
         System.out.println("END");
         if(function_spills.get(curr_function) != 0) System.out.println("// SPILLED");
         else System.out.println("// NOTSPILLED");
      }

      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n, A argu) {
      R _ret=null;

      String call = (String) n.f0.accept(this, argu);

      String sim_exp = (String) n.f1.accept(this, argu);   

      if(iteration == 1) {
         if(sim_exp.equals("v1")) {
            System.out.println("MOVE v0 v1");
            sim_exp = "v0";
         }
      }

      call_exp = true;
      arg_num = 0;

      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);

      if(iteration == 0) {
         max_arg_call = Integer.max(max_arg_call, arg_num);
      }

      if(iteration == 1) {
         for(int i = 0; i<10; i++) {
            System.out.println("ASTORE SPILLEDARG " + stack_locations + " t"+i);
            stack_locations++;
         }
         System.out.println(call + " " + sim_exp);
         for(int i = 0; i<10; i++) {
            System.out.println("ALOAD t"+ i + " SPILLEDARG " + (stack_locations-10+i));
         }
         stack_locations-=10;
      }

      if(iteration == 0) call_exp = false;

      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) {
      R _ret=null;

      String hallocate = (String) n.f0.accept(this, argu);
      type = "use";
      String sim_exp = (String) n.f1.accept(this, argu);
      type = "null";

      if(iteration == 1) {
         _ret = (R) (hallocate + " " + sim_exp);
      }

      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) {
      R _ret=null;

      String operator = (String) n.f0.accept(this, argu);

      type = "use";
      String temp = (String) n.f1.accept(this, argu);

      if(iteration == 1) {
         if(temp.equals("v1")) {
            System.out.println("MOVE v0 v1");
            temp = "v0";
         }
      }

      String sim_exp = (String) n.f2.accept(this, argu);
      type = "null";

      if(iteration == 1) {
         _ret = (R) (operator + " " + temp + " " + sim_exp);
      }
      return _ret;
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public R visit(Operator n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) {
      R _ret=null;

      boolean init = to_print_label;
      to_print_label = false;
      _ret = n.f0.accept(this, argu);
      to_print_label = init;

      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) {
      R _ret=null;
      String allocated_reg = null;

      n.f0.accept(this, argu);
      String temp = (String) n.f1.accept(this, argu);

      if(iteration == 1) {         

         if(allocations.get(curr_function).get(temp) == null) {
            temp = "v1";
            return (R) temp;
         }

         if(allocations_start.get(curr_function).get(temp) > line_number) {
            // System.out.println("this case : " + temp);
            temp = "v1";
            return (R) temp;
         }

         if(!curr_function.equals("MAIN") && Integer.parseInt(temp) < Integer.parseInt(no_of_args)) {
            allocated_reg = allocations.get(curr_function).get(temp);
            if(Integer.parseInt(temp) < 4) {
               if(allocated_reg.charAt(0) == 'l' && type.equals("use")) {
                  System.out.println("ALOAD v1 SPILLEDARG " + allocated_reg.substring(1));
                  allocated_reg = "v1";
               } else if(allocated_reg.charAt(0) == 'l') {
                  to_store_in = allocated_reg.substring(1);
                  allocated_reg = "v0";
               }
            }
            else {
               if(type.equals("use")) {
                  System.out.println("ALOAD v1 SPILLEDARG " + (Integer.parseInt(temp) - 4));
                  if(allocated_reg.charAt(0) == 'l') allocated_reg = "v1";
                  else {
                     System.out.println("MOVE " + allocated_reg + " v1");
                  }
               } else if(type.equals("def")) {
                  to_store_in = Integer.toString((Integer.parseInt(temp) - 4));
                  allocated_reg = "v0";
               }
            }
         }
         
         temp = allocations.get(curr_function).get(temp);

         if(allocated_reg == null) {
            if(temp.charAt(0) == 'l' && type.equals("use")) {
               System.out.println("ALOAD v1 SPILLEDARG " + temp.substring(1));
               temp = "v1";
            } else if(temp.charAt(0) == 'l') {
               to_store_in = temp.substring(1);
               temp = "v0";
            }
         } else temp = allocated_reg;
         

         if(call_exp) {
            if(arg_num < 4) {
               System.out.println("MOVE a" + arg_num + " " + temp);
            } else {
               System.out.println("PASSARG " + (arg_num-3) + " " + temp);
            }
            arg_num++;

            return null;
         }

         return (R) temp;
      }

      if(iteration == 0 && call_exp) {
         arg_num++;
      }
      
      if(iteration == 0) {
         if(type.equals("use")) {
            Set<String> use_var;
            if(use.containsKey(line_number)) {
               use_var = use.get(line_number);
               use_var.add(temp);
               use.replace(line_number, use_var);
            } else {
               use_var = new HashSet<String>();
               use_var.add(temp);
               use.put(line_number, use_var);
            }
         } else if(type.equals("def")) {
            Set<String> def_var;
            if(def.containsKey(line_number)) {
               def_var = def.get(line_number);
               def_var.add(temp);
               def.replace(line_number, def_var);
            } else {
               def_var = new HashSet<String>();
               def_var.add(temp);
               def.put(line_number, def_var);
            }
         }
      }

      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) {
      R _ret=null;
      String label = (String) n.f0.accept(this, argu);

      if(to_print_label) {
         Set<Integer> nei = new HashSet<Integer>();
         line_number++;
         nei.add(line_number+1);
         adj.put(line_number, nei);
         if(iteration == -1) {
            label_allocated.put(curr_function+"_"+label, "L"+curr_label);
            label_line.put(curr_function+"_"+label, line_number);
            curr_label++;
         } else if(iteration == 1) {
            System.out.println(label_allocated.get(curr_function+"_"+label));
         }
      } else if(iteration == 1) {
         if(label_allocated.get(curr_function+"_"+label) != null) {
            label = label_allocated.get(curr_function+"_"+label);
         }
      }

      _ret = (R) label;

      return _ret;
   }

}
