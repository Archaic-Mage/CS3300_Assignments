//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

//import jdk.nashorn.internal.codegen.SpillObjectCreator;



/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJDepthFirst<R,A> implements GJVisitor<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //

   //keeping track of iteration
   int iteration = 0;

   //live intervals
   public class LiveRange {
      String temp;
      int start_line;
      int end_line;
   }

   public class AscendingStart implements Comparator<LiveRange> {
      public int compare(LiveRange l1, LiveRange l2) {
         if(l1.start_line > l2.start_line) return 1;
         else if(l1.start_line < l2.start_line) return -1;
         return 0;
      }     
   }

   public class AscendingEnd implements Comparator<LiveRange> {
      public int compare(LiveRange l1, LiveRange l2) {
         if(l1.end_line > l2.end_line) return 1;
         else if(l1.end_line < l2.end_line) return -1;
         return 0;
      }     
   }

   HashMap<String, Integer> temp_index;

   Vector<LiveRange> live_ranges;

   int line_number = 0;
   String type; // "use" or "def"
   String to_store_in;

   //labels 
   int curr_label = 0;
   HashMap<String, String> label_allocated = new HashMap<String, String>();
   boolean to_print_label = false;

   //register allocated 
   String curr_function;   
   String no_of_args;
   HashMap<String, HashMap<String, String>> allocations = new HashMap<String, HashMap<String, String>>();
   HashMap<String, Integer> function_spills = new HashMap<String, Integer>();
   HashMap<String, Integer> functions_max_call = new HashMap<String, Integer> ();

   //for allocations
   PriorityQueue<LiveRange> active;
   PriorityQueue<LiveRange> live_intervals;

   //registers
   int available_registers = 18;
   HashMap<String, Boolean> free_registers;
   HashMap<LiveRange, String> register;

   int stack_locations = 0;
   int spills = 0;
   int max_arg_call;
   boolean call_exp = false;
   int arg_num = 0;

   public void initialize() {
      //for live ranges
      live_intervals = new PriorityQueue<LiveRange>(live_ranges.size(), new AscendingStart());

      for(LiveRange t: live_ranges) {
         if(curr_function.equals("MAIN") || (t.start_line != t.end_line) || Integer.parseInt(no_of_args) < Integer.parseInt(t.temp)) live_intervals.add(t);
      }

      register = new HashMap<LiveRange, String> ();
      free_registers = new LinkedHashMap<String, Boolean> ();

      //s0-7
      for(int i = 0; i<8; i++) {
         String reg = "s"+i;
         free_registers.put(reg, true);
      }
      
      //t0-9
      for(int i = 0; i<10; i++) {
         String reg = "t"+i;
         free_registers.put(reg, true);
      }
   }

   public void addFreedReg(String reg) {
      free_registers.replace(reg, true);
   }

   public String getFreeReg() {
      for(String reg: free_registers.keySet()) {
         if(free_registers.get(reg)) {
            free_registers.replace(reg, false);
            return reg;
         }
      }

      return null;
   }

   public void expireOldIntervals(LiveRange i) {
      while(!active.isEmpty()) {
         LiveRange j = active.peek();
         if(j.end_line > i.start_line) return;
         active.poll();
         addFreedReg(register.get(j));
      }
   }

   public LiveRange getLastInterval() {
      Vector<LiveRange> temp = new Vector<LiveRange>();
      while(!active.isEmpty()) {
         temp.add(active.poll());
      }
      LiveRange last = temp.lastElement();
      for(LiveRange t: temp) {
         active.add(t);
      }
      temp.clear();
      return last;
   }

   public void spillAtInterval(LiveRange i) {
      LiveRange spill = getLastInterval();   
      int args = Integer.parseInt(no_of_args);
      if(args > 4) args -= 4;
      else args = 0;
      String location = "l"+(spills+args);
      spills++;

      if(spill.end_line > i.end_line) {
         register.put(i, register.get(spill));
         register.replace(spill, location);
         active.remove(spill);
         active.add(i);
      } else {
         register.put(i, location);
      }
   }

   public void allocateRegisters() {
      initialize();
      
      active = new PriorityQueue<LiveRange> (live_ranges.size(), new AscendingEnd());

      while(!live_intervals.isEmpty()) {
         LiveRange i = live_intervals.poll();
         expireOldIntervals(i);
         if(active.size() == available_registers) 
            spillAtInterval(i);
         else {
            String toAllocate = getFreeReg();
            register.put(i, toAllocate);
            active.add(i);
         }
      }

   }

	
   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return (R)n.tokenImage; }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */

   
   public R visit(Procedure n, A argu) {
      R _ret=null;
      line_number++;
      call_exp = false;
      max_arg_call = -1;
      int stack_size = 8;
      spills = 0;

      String label = (String) n.f0.accept(this, argu);
      curr_function = label;

      if(iteration == 1) {
         max_arg_call = functions_max_call.get(curr_function);
         if(max_arg_call == -1) {
            max_arg_call = 0;
         } else stack_size+=(10);
      }

      n.f1.accept(this, argu);

      String int_literal = (String) n.f2.accept(this, argu);    

      n.f3.accept(this, argu);

      if(iteration == 1) {
         int arguments = Integer.parseInt(int_literal);
         if(arguments > 4) {
            stack_size+=(arguments-4); 
            stack_locations=(arguments-4);
         }
         int spill = function_spills.get(curr_function);
         if(spill != 0) {
            stack_size += spill;
            stack_locations += spill;
         }
         System.out.println(label + " [" + int_literal + "] [" + stack_size + "] [" + max_arg_call + "]");
      }

      //initializing for the live ranges
      temp_index = new HashMap<String, Integer>();
      live_ranges = new Vector<LiveRange> ();
      no_of_args = int_literal;

      if(iteration == 0) {
         for(int i = 0; i<Integer.parseInt(int_literal); i++) {
            LiveRange t = new LiveRange();
            String temp = Integer.toString(i);
            t.temp = temp;
            t.start_line = line_number;
            t.end_line = line_number;
            temp_index.put(temp, live_ranges.size());
            live_ranges.add(t);
         }
      }
      
      n.f4.accept(this, argu);

      if(iteration == 0) allocateRegisters();

      if(iteration == 0) {
         HashMap<String, String> temp = new HashMap<String, String> ();
         // System.out.println(curr_function);

         for(LiveRange t: register.keySet()) {
            // System.out.println(t.temp + ": " + register.get(t));
            temp.put(t.temp, register.get(t));
         }

         allocations.put(curr_function, temp);
         function_spills.put(curr_function, spills);
         functions_max_call.put(curr_function, max_arg_call);
      }

      return _ret;
   }

//
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      R _ret=null;

      line_number++;
      n.f0.accept(this, argu);
      curr_function = "MAIN";
      call_exp = false;
      max_arg_call = -1;
      int stack_size = 0;
      spills = 0;
      no_of_args = "0";

      if(iteration == 1) {
         max_arg_call = functions_max_call.get(curr_function);
         if(max_arg_call == -1) {
            max_arg_call = 0;
         } else stack_size+=(10);

         int spill = function_spills.get(curr_function);
         if(spill != 0) {
            stack_size += spill;
            stack_locations = spill;
         }

         System.out.println("MAIN [" + no_of_args + "] [" + stack_size + "] [" + max_arg_call + "]");
      }

      //initializing for the live ranges
      temp_index = new HashMap<String, Integer>();
      live_ranges = new Vector<LiveRange> ();

      n.f1.accept(this, argu);

      if(iteration == 0) {
         allocateRegisters();
      }
      line_number++;
      n.f2.accept(this, argu);

      if(iteration == 1) {
         System.out.println("END");
         if(function_spills.get(curr_function) != 0) System.out.println("// SPILLED");
         else System.out.println("// NOTSPILLED");
      }
      
      if(iteration == 0) {
         HashMap<String, String> temp = new HashMap<String, String> ();

         for(LiveRange t: register.keySet()) {
            // System.out.println(t.temp + ": " + register.get(t));
            temp.put(t.temp, register.get(t));
         }

         allocations.put(curr_function, temp);
         function_spills.put(curr_function, spills);
         functions_max_call.put(curr_function, max_arg_call);
      }

      n.f3.accept(this, argu);
      n.f4.accept(this, argu);  
      
      iteration++;

      return _ret;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
      R _ret=null;
      to_print_label = true;
      n.f0.accept(this, argu);
      to_print_label = false;
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) {
      R _ret=null; 
      line_number++; 
      n.f0.accept(this, argu);      
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      if(iteration == 1) {
         System.out.println("NOOP");
      }
      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      if(iteration == 1) {
         System.out.println("ERROR");
      }
      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) {
      R _ret=null;
      String cjump = (String) n.f0.accept(this, argu);

      type = "use";
      String use_temp = (String) n.f1.accept(this, argu);
      type = "null";

      boolean init = to_print_label;
      to_print_label = false;
      String label = (String) n.f2.accept(this, argu);
      to_print_label = init;

      if(iteration == 1) System.out.println(cjump + " " + use_temp +" " + label);
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) {
      R _ret=null;
      String jump = (String) n.f0.accept(this, argu);
      boolean init = to_print_label;
      to_print_label = false;
      String label = (String) n.f1.accept(this, argu);
      to_print_label = init;
      if(iteration == 1) System.out.println(jump + " " + label);
      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) {
      R _ret=null;

      String hstore = (String) n.f0.accept(this, argu);

      type = "use";
      String def_temp = (String) n.f1.accept(this, argu);
      type = "null";     

      String int_literal = (String) n.f2.accept(this, argu);

      type = "use";
      String use_temp = (String) n.f3.accept(this, argu);
      type = "null";

      if(iteration == 1) {
         System.out.println(hstore + " " + def_temp + " " + int_literal + " " + use_temp);
         if(def_temp.equals("v0")) System.out.println("ASTORE SPILLEDARG " + to_store_in + " v0");
      }
      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) {
      R _ret=null;

      String hload = (String) n.f0.accept(this, argu);

      type = "def";
      String def_temp = (String) n.f1.accept(this, argu);
      type = "null";

      type = "use";
      String use_temp = (String) n.f2.accept(this, argu);
      type = "null";

      String int_literal = (String) n.f3.accept(this, argu);

      if(iteration == 1) {
         System.out.println(hload + " " + def_temp + " " + use_temp + " " + int_literal);
         if(def_temp.equals("v0")) System.out.println("ASTORE SPILLEDARG " + to_store_in + " v0");
      }
      
      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) {
      R _ret=null;

      String move = (String) n.f0.accept(this, argu);

      type = "def";
      String temp = (String) n.f1.accept(this, argu); 
      type = "null";

      type = "use";
      String exp = (String) n.f2.accept(this, argu);
      type = "null";

      if(call_exp && iteration == 1) {
         System.out.println(move + " " + temp + " v0");
         if(temp.equals("v0")) System.out.println("ASTORE SPILLEDARG " + to_store_in + " v0");
         call_exp = false;
      } else if(iteration == 1) {
         System.out.println(move + " " + temp + " " + exp);
         if(temp.equals("v0")) System.out.println("ASTORE SPILLEDARG " + to_store_in + " v0");
      }

      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) {
      R _ret=null;
      String prit = (String) n.f0.accept(this, argu);
      type = "use";
      String sim_exp = (String) n.f1.accept(this, argu);    
      type = "null";

      if(iteration == 1) {
         System.out.println(prit + " " + sim_exp);
      }

      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) {
      R _ret=null;
      type = "use";
      _ret = n.f0.accept(this, argu);
      type = "null";
      return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n, A argu) {
      R _ret=null;
      line_number++;
      n.f0.accept(this, argu);

      if(iteration == 1) {
         for(int i = 0; i<8; i++) {
            System.out.println("ASTORE SPILLEDARG " + stack_locations + " s"+i);
            stack_locations++;
         }
         int till = Integer.min(Integer.parseInt(no_of_args), 4);
         for(int i = 0; i<till; i++) {
            String al_reg = allocations.get(curr_function).get(Integer.toString(i));
            if(al_reg != null) System.out.println("MOVE " + al_reg + " a" + i);
         }
      }

      n.f1.accept(this, argu);
      line_number++;
      n.f2.accept(this, argu);
      type = "use";
      String sim_exp = (String) n.f3.accept(this, argu);
      type = "null";
      line_number++;
      n.f4.accept(this, argu);

      if(iteration == 1) {
         System.out.println("MOVE v0 " + sim_exp);
         for(int i = 0; i<8; i++) {
            System.out.println("ALOAD s"+i + " SPILLEDARG " + (stack_locations - 8+i));
         }
         stack_locations-=8;
         System.out.println("END");
         if(function_spills.get(curr_function) != 0) System.out.println("// SPILLED");
         else System.out.println("// NOTSPILLED");
      }

      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n, A argu) {
      R _ret=null;
      String call = (String) n.f0.accept(this, argu);
      String sim_exp = (String) n.f1.accept(this, argu);      
      call_exp = true;
      arg_num = 0;
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);

      if(iteration == 0) {
         max_arg_call = Integer.max(max_arg_call, arg_num);
      }

      if(iteration == 1) {
         for(int i = 0; i<10; i++) {
            System.out.println("ASTORE SPILLEDARG " + stack_locations + " t"+i);
            stack_locations++;
         }
         System.out.println(call + " " + sim_exp);
         for(int i = 0; i<10; i++) {
            System.out.println("ALOAD t"+ i + " SPILLEDARG " + (stack_locations-10+i));
         }
         stack_locations-=10;
      }

      if(iteration == 0) call_exp = false;

      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) {
      R _ret=null;
      String hallocate = (String) n.f0.accept(this, argu);
      type = "use";
      String sim_exp = (String) n.f1.accept(this, argu);
      type = "null";

      if(iteration == 1) {
         _ret = (R) (hallocate + " " + sim_exp);
      }

      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) {
      R _ret=null;
      String operator = (String) n.f0.accept(this, argu);
      type = "use";
      String temp = (String) n.f1.accept(this, argu);
      String sim_exp = (String) n.f2.accept(this, argu);
      type = "null";

      if(iteration == 1) {
         _ret = (R) (operator + " " + temp + " " + sim_exp);
      }
      return _ret;
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public R visit(Operator n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) {
      R _ret=null;
      boolean init = to_print_label;
      to_print_label = false;
      _ret = n.f0.accept(this, argu);
      to_print_label = init;
      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) {
      R _ret=null;

      n.f0.accept(this, argu);
      String temp = (String) n.f1.accept(this, argu);

      if(iteration == 1) {
         if(call_exp) {
            if(arg_num < 4) {
               System.out.println("MOVE a" + arg_num + " " + allocations.get(curr_function).get(temp));
            } else {
               System.out.println("PASSARG " + (arg_num-3) + " " + allocations.get(curr_function).get(temp));
            }
            arg_num++;

            return null;
         }

         

         if(!curr_function.equals("MAIN") && Integer.parseInt(temp) < Integer.parseInt(no_of_args)) {
            String allocated_reg = allocations.get(curr_function).get(temp);
            if(Integer.parseInt(temp) < 4) {
               temp = allocated_reg;
            }
            else {
               if(type.equals("use")) {
                  System.out.println("ALOAD v1 SPILLEDARG " + (Integer.parseInt(temp) - 4));
                  System.out.println("MOVE " + allocated_reg + " v1");
                  temp = allocated_reg;
               } else if(type.equals("def")) {
                  to_store_in = Integer.toString((Integer.parseInt(temp) - 4));
                  temp = "v0";
               }
            }

            return (R) temp;
         }
         
         temp = allocations.get(curr_function).get(temp);
         if(temp.charAt(0) == 'l' && type.equals("use")) {
            System.out.println("ALOAD v1 SPILLEDARG " + temp.substring(1));
            temp = "v1";
         } else if(temp.charAt(0) == 'l') {
            to_store_in = temp.substring(1);
            temp = "v0";
         }

         return (R) temp;
      }

      if(iteration == 0 && call_exp) {
         arg_num++;
      }
      
      if(iteration == 0 && type.equals("use")) {
         int index = temp_index.get(temp);
         LiveRange t = live_ranges.get(index);
         t.end_line = line_number;
      } else if(iteration == 0 && type.equals("def")) {
         LiveRange t;
         int index;
         if(temp_index.get(temp) == null) {
            t = new LiveRange();
            t.temp = temp;
            t.start_line = line_number;
            t.end_line = line_number;
            index = live_ranges.size();
            temp_index.put(temp, index);
            live_ranges.add(t);
         }
      }

      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) {
      R _ret=null;
      String label = (String) n.f0.accept(this, argu);

      if(to_print_label) {
         if(iteration == 0) {
            line_number++;
            label_allocated.put(curr_function+"_"+label, "L"+curr_label);
            curr_label++;
         } else if(iteration == 1) {
            System.out.println(label_allocated.get(curr_function+"_"+label));
         }
      } else {
         if(label_allocated.get(curr_function+"_"+label) != null) {
            label = label_allocated.get(curr_function+"_"+label);
         }
      }

      _ret = (R) label;

      return _ret;
   }

}
